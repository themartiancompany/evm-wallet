#!/usr/bin/env bash

# SPDX-License-Identifier: AGPL-3.0-or-later

#    ----------------------------------------------------------------------
#    Copyright Â© 2024, 2025, 2026  Pellegrino Prevete
#
#    All rights reserved
#    ----------------------------------------------------------------------
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Affero General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU Affero General Public License for more details.
#
#    You should have received a copy of the GNU Affero General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

_bin="$(
  dirname \
    "$(command \
        -v \
        "env")")"
_lib="$(
  realpath \
    "${_bin}/../lib")"
_crash_bash="${_lib}/libcrash-bash/crash-bash"
_libevm="${_lib}/libevm/libevm"
_sourced \
  "${_crash_bash}" 2>/dev/null || \
  source \
    "${_crash_bash}"
_sourced \
  "${_libevm}"

# shellcheck disable=SC2034
_global_variables() {
  call_date=""
  cache_dir=""
  tasks_parallel=""
  target_networks=()
  networks_amount=""
  target_command=""
  target_key=""
  target_value=""
  output_type=""
  currency_type=""
  currency_address=""
  networks_all=""
  rpc_selection=""
  key_fingerprint=""
  explorer_selection=""
  retries_max=""
  measure_unit=""
  balance_lifespan=""
  command_args=()
  color=""
  quiet=""
}

_requirements() {
  _check_cmd \
    'libevm-requirements' \
    'libevm'
  libevm-requirements
  _check_cmd \
    'node-run'
  _check_cmd \
    "evm-chains-info"
  _check_cmd \
    "evm-chains-explorers"
}

_key_fingerprint_requirements() {
  local \
    _required="${1}" \
    _msg_type \
    _msg_args=() \
    _msg=()
  _evm_gpg_available="$(
    command \
      -v \
      "evm-gpg" || \
      true)"
  if [[ "${_evm_gpg_available}" == "" ]]; then
    _msg=(
      "Install Ethereum Virtual"
      "Machine GNU Privacy Guard"
      "to use OpenPGP on Ethereum."
      "More information is available"
      "by typing 'man evm-wallet'."
    )
    _msg_type="info"
    _msg_args=(
      "${_msg[*]}"
    )
    if [[ "${_required}" == "y" ]]; then
      _msg_type="error"
      _msg_args+=(
        1
      )
    fi
    "_msg_${_msg_type}" \
      "${_msg_args[@]}"
  fi
}

_get_conf_dir_path() {
  local \
    _dir
  _dir="${HOME}/.config/${app_name}"
  echo \
    "${_dir}"
}

_balance_age_get() {
  local \
    _balance_file="${1}" \
    _now \
    _balance_modified \
    _msg=()
  _balance_age=""
  if [[ ! -e "${_balance_file}" ]]; then
    _msg=(
      "Balance for account"
      "'${_wallet_name}' never"
      "retrieved for network"
      "'${_target_network}'."
    )
  _msg_info \
    "${_msg[*]}"
  else 
    _now="$(
      date \
      "+%s")"
    _balance_modified="$(
      date \
        -r \
          "${_balance_file}" \
        "+%s")"
    _balance_age="$(( \
      "${_now}" - \
      "${_balance_modified}" ))"
  fi
}

_balance_send() {
  local \
    _currency_type="${1}" \
    _currency_address="${2}" \
    _target_address="${3}" \
    _target_amount="${4}" \
    _lib \
    _msg=()
  _lib="$(
    _get_lib)/evm-wallet"
  _cmd=""
  if [[ "${_currency_type}" == "gas" ]]; then
    _cmd="${_lib}/balance-send"
    _args+=(
      "${quiet}"
      "${_wallet_seed}"
      "${_target_address}"
      "${_target_amount}"
      "${_rpc_backend}"
      "${_api_key_path}"
    )
  elif [[ "${_currency_type}" == "erc20" ]]; then
    _cmd="${_lib}/token-send"
    _args+=(
      "${quiet}"
      "${retries_max}"
      "${call_timeout}"
      "${wallet_seed}"
      "${api_key_path}"
      "${token_bytecode_path}"
      "${token_compiler_output_path}"
      "${measure_unit}"
      "${receipt_file_path}"
      "${target_address}"
      "${target_amount}"
    )
  fi
  _msg=(
    "Running send program"
    "'${_cmd}'"
    "with arguments '${_args[*]}'."
  )
  _msg_info \
    "${_msg[*]}"
}

_wallet_key_cmd() {
  local \
    _key="${1}" \
    _command="${2}" \
    _lib
  _lib="$(
    _get_lib)/evm-wallet"
  echo \
    "${_lib}/${_key}-${_command}"
}

_balance_get_cmd_get() {
  local \
    _wallet_name="${1}" \
    _target_network="${2}" \
    _balance_age \
    _balance_file \
    _network_dir \
    _node_run \
    _node_run_opts=() \
    _rpc_backend \
    _success \
    _exit
  _exit="1"
  _success="true"
  if (( 2 < "${#}" )); then
    _exit="${3}"
  fi
  _node_main="false"
  _node_run_opts+=(
    -r
      "${_retries_max}"
  )
  _network_dir="${_cache_dir}/${_wallet_name}/${_target_network}"
  _balance_file="${_network_dir}/balance"
  _disabled_file="${_network_dir}/disabled"
  if [[ -e "${_disabled_file}" ]]; then
    _msg=(
      "Network '${_target_network}' disabled,"
      "skipping."
    )
    _msg_info \
      "${_msg[*]}"
    return
  fi
  if [[ ! -d "${_cache_dir}" ]]; then
    _msg=(
      "Cache directory"
      "'${_cache_dir}'"
      "does not exist."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  mkdir \
    -p \
    "${_network_dir}"
  _balance_update="true"
  _balance_age_get \
    "${_balance_file}"
  if [[ "${_balance_age}" != "" ]]; then
    if (( "${_balance_age}" < "${_balance_lifespan}" )); then
      _balance_update="false"
      _msg=(
        "Skipping balance update."
      )
      _msg_info \
        "${_msg[*]}"
    fi
  fi
  if [[ "${_balance_update}" == "true" ]]; then
    _node_run="true"
    _rpc_backend_get \
      "${_target_network}" \
      "${_rpc_selection}"
    _cmd="$(
      "_wallet_key_cmd" \
        "${_key}" \
        "get")"
    if [[ "${_rpc_backend}" == "" ]]; then
      _msg=(
        "No RPC backends found,"
        "ignoring network '${_target_network}'."
      )
      _msg_info \
        "${_msg[*]}"
      _node_run="false"
      touch \
        "${_disabled_file}"
    fi
    _args=(
      "${quiet}"
      "${_wallet_seed}"
      "${_rpc_backend}"
      "${_api_key_path}"
      "${wallet_address}"
      "${measure_unit}"
      "${_balance_file}"
      "${_retries_max}"
    )
  elif [[ "${_balance_update}" == "false" ]]; then
    cat \
      "${_balance_file}" || \
    true
    _node_run="false"
  fi
  if [[ "${_node_run}" == "true" ]]; then
    if [[ "${quiet}" == "y" ]]; then
      node-run \
        "${_node_run_opts[@]}" \
        "${_cmd}" \
        "${_args[@]}" \
        1>"/dev/null" || \
        _success="false"
    elif [[ "${quiet}" == "n" ]]; then
      node-run \
        "${_node_run_opts[@]}" \
        "${_cmd}" \
        "${_args[@]}" || \
        _success="false"
    fi
    if [[ "${_success}" == "false" ]]; then
      _msg=(
        "Error retrieving balance"
        "for network '${_target_network}', disabling."
      )
      touch \
        "${_disabled_file}"
      _msg_error \
        "${_msg[*]}" \
        "${_exit}"
    fi
  fi
}

_address_get() {
  local \
    _quiet="${1}" \
    _wallet_seed="${2}" \
    _address_file
  _wallet_address=""
  _address_file="${_wallet_seed%-seed.txt}-address.txt"
  if [[ ! -e "${_address_file}" ]]; then
    _cmd="$(
      "_wallet_key_cmd" \
        "address" \
        "get")"
    _rpc_backend=""
    _args=(
      "${_quiet}"
      "${_wallet_seed}"
      "${_rpc_backend}"
      "${_api_key_path}"
      "${_address_file}"
    )
    if [[ "${quiet}" == "y" ]]; then
      node-run \
        "${_node_run_opts[@]}" \
        "${_cmd}" \
        "${_args[@]}" 1>/dev/null
    elif [[ "${quiet}" == "n" ]]; then
      node-run \
        "${_node_run_opts[@]}" \
        "${_cmd}" \
        "${_args[@]}"
    fi
  fi
  _wallet_address="$(
    cat \
      "${_address_file}")"
}

_key_fingerprint_get() {
  local \
    _wallet_name="${1}" \
    _evm_gpg_opts=()
  _evm_gpg_opts+=(
    -N
      "${_wallet_name}"
    -o
      "fingerprint"
  )
  evm-gpg \
    "${_evm_gpg_opts[@]}" -- \
    "list" || \
    true
}

_fingerprint_get() {
  local \
    _wallet_name="${1}" \
    _address_file \
    _config_dir
  _config_dir="$(
    _get_conf_dir_path)"
  _fingerprint_file="${_config_dir}/${_wallet_name}-fingerprint.txt"
  if [[ ! -e "${_fingerprint_file}" ]]; then
    _key_fingerprint_get \
      "${_wallet_name}" > \
      "${_fingerprint_file}"
  fi
  _fingerprint="$(
    cat \
      "${_fingerprint_file}")"
}

# NOTE: This parallel processes method
# is currently unused.
_balance_get_async() {
  local \
    _tasks_parallel="${1}" \
    _wallet_name="${2}" \
    _exit="${3}" \
    _balance_get_base_opts=() \
    _balance_get_opts=() \
    _networks=() \
    _network \
    _index \
    _pending \
    _pendings=() \
    _pendings_new=() \
    _msg=() \
    _job \
    _wait_opts=()
  _node_main="false"
  _balance_get_base_opts+=(
    "${wallet_name}"
  )
  shift \
    3
  _networks=(
    "$@"
  )
  _networks_total="${#_target_networks[@]}"
  _wait_opts+=(
    -f
    -p
      "_job"
    -n
  )
  _index=0
  while \
    [ "${_index}" -le "$(("${_networks_total}" - 1))" ] && \
    [ "${#_pendings[@]}" -le "${_tasks_parallel}" ]; do
    _network="${_networks["${_index}"]}"
    _balance_get_opts=(
      "${_balance_get_base_opts[@]}"
      "${_network}"
      "0"
    )
    _run \
      "_balance_get_${_index}_${_network}" \
      "0" \
      "async" \
      "_balance_get_cmd_get" \
        "${_balance_get_opts[@]}"
    _pendings+=(
      "$(_get_pid \
           "_balance_get_${_index}_${_network}")"
    )
    _index="$((
      _index + 1 ))"
    if [[ "${#_pendings[@]}" == "${_tasks_parallel}" ]]; then 
      wait \
        "${_wait_opts[@]}" \
        "${_pendings[@]}"
      _pendings_new=()
      for _pending in "${_pendings[@]}"; do
        if [[ "${_pending}" != "${_job}" ]]; then
          _pendings_new+=(
            "${_pending}"
          )
        fi
      done
      _pendings=(
        "${_pendings_new[@]}"
      )
      _job=""
    fi
  done
  wait \
    "${_pendings[@]}"
}

_key_get() {
  local \
    _key="${1}" \
    _output_file \
    _output_dir \
    _evm_chains_info_opts=() \
    _network
  if [[ "${_key}" == "address" ]]; then
    "_${_key}_get" \
      "${quiet}" \
      "${_wallet_seed}"
    echo \
      "${_wallet_address}"
    exit \
      0
  elif [[ "${_key}" == "balance" ]]; then
    _rpc_backend_get \
      "${_target_network}" \
      "${_rpc_selection}"
    # _balance_get_async \
    #   "${_tasks_parallel}" \
    #   "${wallet_name}" \
    #   "${_target_network}" \
    #   "0"
    "_${_key}_get_cmd_get" \
      "${wallet_name}" \
      "${_target_network}" \
      "0"
  elif [[ "${_key}" == "seed" ]]; then
    cat \
      "${_wallet_seed}"
    exit \
      0
  elif [[ "${_key}" == "name" ]]; then
    echo \
      "${wallet_name}"
    return \
      0
  elif [[ "${_key}" == "fingerprint" ]]; then
    _fingerprint_get \
      "${wallet_name}"
    return \
      0
  fi
}

_wallets_sort() {
  local \
    _wallets_names_unsorted=() \
    _wallet \
    _wallet_name \
    _msg=()
  if (( 0 == "${#_wallets_files[@]}" )); then
    _msg=(
      "No wallets found."
    )
    _msg_info \
      "${_msg[*]}"
  elif (( 0 < "${#_wallets_files[@]}" )); then
    _wallets_dir="$(
      dirname \
        "${_wallets_files[@]}")"
    for _wallet in "${_wallets_files[@]}"; do
      _wallet_name="$(
        basename \
          "${_wallet}")"
      _wallet_names_unsorted+=(
        "${_wallet_name}" 
      )
    done
    _wallets_names=( $(
      printf \
        '%s\n' \
        "${_wallet_names_unsorted[@]}")
    )
  fi
}

_wallets_files_get() {
  local \
    _dir="${1}" \
    _filter="${2}" \
    _find_opts=()
  _find_opts+=(
    -wholename
      "*${_filter}*-*.txt"
    -type \
      "f" \
    -print0
  )
  mapfile \
    -d \
    $'\0' \
    _wallets_files < \
    <(find \
        "${_dir}" \
        "${_find_opts[@]}" || \
      true)
}

_contacts_display_full() {
  local \
    _address \
    _counter \
    _printf_args=() \
    _printf_template=() \
    _wallet_address \
    _fingerprint
  _counter="0"
  for _address in \
    "${!_addresses[@]}"; do
    _counter="$(( \
      "${_counter}" + \
      1 ))"
    _printf_args=(
                "        Name: ${_address}"
    )
    _wallet_address="${_addresses["${_address}"]}"
    _fingerprint="${_fingerprints["${_address}"]}"
    if [[ " ${!_wallets[@]} " == *" ${_address} "* ]]; then
      _printf_args+=(
        "           Private key: yes"
      )
    fi
    _printf_args+=(
      "               Address: ${_wallet_address}" \
    )
    _printf_args+=(
      "   OpenPGP fingerprint: ${_fingerprint}" \
    )
    _printf_template=(
      "%s" "\n"
      "%s" "\n"
      "%s" "\n"
      "%s" "\n"
    )
    if [[ "${_counter}" != "${_addresses_amount}" ]]; then
      _printf_template+=(
        "\n"
      )
    fi
    printf \
      "${_printf_template[*]}" \
      "${_printf_args[@]}"
  done
}

_contacts_field_display() {
  local \
    _field="${1}" \
    _name \
    _counter \
    _result \
    _results=()
  _counter="0"
  for _name in \
    "${!_addresses[@]}"; do
    _counter="$(( \
      "${_counter}" + \
      1 ))"
    if [[ "${_field}" == "name" ]]; then
      _result="${_address}"
    elif [[ "${_field}" == "address" ]]; then
      _result="${_addresses["${_name}"]}"
    elif [[ "${_field}" == "fingerprint" ]]; then
      _result="${_fingerprints["${_name}"]}"
    else
      _msg=(
        "Unknown field '${_field}'."
      )
      _msg_error \
        "${_msg[*]}" \
        1
    fi
    _results+=(
      "${_result}"
    )
    done
    printf \
      '%s\n' \
      "${_results[@]}" |
      sort \
        -V
}

_contacts_list() {
  local \
    _filter="${1}" \
    _output_type="${2}" \
    _msg=() \
    _wallets_files=() \
    _wallets_names=() \
    _wallet \
    _wallets_dir \
    _wallet_name \
    _wallet_address \
    _wallet_seed \
    _file_name \
    _fingerprint \
    _config_dir
  declare \
    -A \
    _addresses
  declare \
    -A \
    _wallets
  declare \
    -A \
    _fingerprints
  if [[ "${_filter}" == "" ]]; then
    _filter="*"
  fi
  _config_dir="$(
    _get_conf_dir_path)"
  _wallets_files_get \
    "${_config_dir}" \
    "${_filter}"
  _wallets_sort
  for _wallet \
    in "${_wallets_files[@]}"; do
    _file_name="$(
      basename \
        "${_wallet}")"
    if [[ "${_file_name}" == *"-seed.txt" ]]; then
      _wallet_name="${_file_name%-seed.txt}"
      _wallets["${_wallet_name}"]="${_config_dir}/${_file_name}"
    elif [[ "${_file_name}" == *"-address.txt" ]]; then
      _wallet_name="${_file_name%-address.txt}"
      _addresses["${_wallet_name}"]="$(
       cat \
         "${_wallet}")" 
       if [[ "${_output_type}" == "" || \
             "${_output_type}" == "fingerprint" ]]; then
         _msg=(
           "Getting fingerprint for contact '${_wallet_name}'".
         )
         _msg_info \
           "${_msg[*]}"
         _fingerprint_get \
           "${_wallet_name}"
         _fingerprints["${_wallet_name}"]="${_fingerprint}"
       fi
    fi
  done
  for _wallet in \
    "${!_wallets[@]}"; do
    if [[ ! " ${!_addresses[@]} " == *" ${_wallet} "* ]]; then
      _msg=(
        "Getting address for own account"
        "'${_wallet}'."
      )
      _msg_info \
       "${_msg[*]}"
      _wallet_seed="${_wallets["${_wallet}"]}"
      _address_get \
        "y" \
        "${_wallet_seed}"
      _addresses["${_wallet}"]="${_wallet_address}"
      _msg=(
        "Done."
      )
      _msg_info \
        "${_msg[*]}"
    fi
    # if [[ "${_addresses["${_wallet}"]}" == "" ]]; then
    #   exit \
    #     0
    # fi
  done
  _addresses_keys=(
    "${!_addresses[@]}"
  )
  _addresses_amount="${#_addresses_keys[@]}"
  if [[ "${_output_type}" == "" ]]; then
    _contacts_display_full
  else
    _contacts_field_display \
      "${_output_type}"
  fi
  exit \
    0
}

_evm_wallet_sync() {
  for _target_network \
    in "${_target_networks[@]}"; do
    if [[ "${_target_command}" == "get" ]]; then
      "_key_${_target_command}" \
        "${_target_key}"
      if [[ "${_target_key}" == "name" ]]; then
        return \
          0
      fi
    elif [[ "${_target_command}" == "send" ]]; then
      _rpc_backend_get \
        "${_target_network}" \
        "${_rpc_selection}"
      _target_address="${_target_key}"
      _target_amount="${_target_value}"
      _balance_send \
        "${_currency_type}" \
        "${_currency_address}" \
        "${_target_address}" \
        "${_target_amount}"
    elif [[ "${_target_command}" == "list" ]]; then
      _contacts_list \
        "${_target_key}" \
        "${_output_type}"
    elif [[ "${_target_command}" == "approve" ]]; then
      echo \
        "WIP"
      # TODO: write approve function
      # _approve_call_opts_setup
      # evm-contract-call \
      #   "${_approve_call_opts[@]}" \
      #   "${}"
    else
      _msg=(
        "Unknown command '${_target_command}'."
      )
      _msg_error \
        "${_msg[*]}" \
        1
    fi
    if [[ "${_node_main}" == "true" ]]; then
      node-run \
        "${_node_run_opts[@]}" \
        "${_cmd}" \
        "${_args[@]}" || \
      true
    fi
  done
}

_key_get_async() {
  local \
    _key="${1}" \
    _exit
  _exit="0"
  if [[ "${_target_key}" == "balance" ]]; then
    _balance_get_async \
      "${_tasks_parallel}" \
      "${wallet_name}" \
      "${_exit}" \
      "${_target_networks[@]}"
  fi
}

_evm_wallet_async() {
  if [[ "${_target_command}" == "get" ]]; then
    _key_get_async \
      "${_target_key}"
  fi
}

_evm_wallet() {
  local \
    _target_command="${1}" \
    _wallet_path="${2}" \
    _wallet_password="${3}" \
    _wallet_seed="${4}" \
    _key_fingerprint="${5}" \
    _cache_dir="${6}" \
    _networks_all="${7}" \
    _rpc_selection="${8}" \
    _api_key_path="${9}" \
    _retries_max="${10}" \
    _tasks_parallel="${11}" \
    _measure_unit="${12}" \
    _balance_lifespan="${13}" \
    _currency_type="${14}" \
    _currency_address="${15}" \
    _output_type="${16}" \
    _target_key="${17}" \
    _target_value="${18}" \
    _networks_amount="${19}" \
    _target_networks=() \
    _command_args=() \
    _target_networks=() \
    _msg=() \
    _cmd \
    _args=() \
    _network \
    _node_main \
    _rpc_backend \
    _node_run_opts=() \
    _approve_call_opts=() \
    _rpc_backend
  shift \
    19
  if (( 0 < "${_networks_amount}" )); then
    for _network \
      in $(seq \
             "1" \
             "${_networks_amount}"); do
      _network="${1}"
      _target_networks+=(
        "${_network}"
      )
      shift
    done
  fi
  _command_args+=(
    "$@"
  )
  _node_main="true"
  if [[ "${quiet}" == "y" ]]; then
    _node_run_opts+=(
      -v
    )
  fi
  _node_run_opts+=(
    -r
      "${_retries_max}"
  )
  if [[ "${_networks_all}" == "y" ]]; then
    _evm_chains_info_opts+=(
      -a
      -o
        "id"
      -s
        "all"
    )
    _target_networks=( $(
      evm-chains-info \
        "${_evm_chains_info_opts[@]}")
    )
  fi
  if [[ "${_target_command}" == "get" ]]; then
    if [[ "${_target_key}" == "balance" ]]; then
      _evm_wallet_async
    else
      _evm_wallet_sync
    fi
  else
    _evm_wallet_sync
  fi
}

_currency_type_auto_detect() {
  local \
    _currency_type
  _currency_type=""
  if [[ "${currency_address}" == "" ]]; then
    currency_type="gas"
  elif [[ "${currency_address}" != "" ]]; then
    currency_type="erc20"
  fi
  _set_override \
    "currency" \
    "type" \
    "${_currency_type}"
}

_cache_dir_auto_detect() {
  local \
    _dir
  _dir="${HOME}/.cache/${app_name}"
  if [[ ! -v "override_cache_dir" ]]; then
    mkdir \
      -p \
      "${_dir}"
  fi
  _set_override \
    "cache" \
    "dir" \
    "${_dir}"
}

_target_key_auto_detect() {
  local \
    _key
  _key=""
  if [[ "${target_command}" == "get" ]]; then
    _key="name"
  fi
  _set_override \
    "target" \
    "key" \
    "${_key}"
}

_key_fingerprint_auto_detect() {
  local \
    _evm_gpg_available \
    _evm_gpg_opts=() \
    _msg=() \
    _fingerprint
  _key_fingerprint_requirements \
    "n"
  if [[ "${_evm_gpg_available}" != "" ]]; then
    if [[ "${wallet_name}" != "" ]]; then
      _fingerprint_get \
        "${wallet_name}"
      _key_fingerprint="${_fingerprint}"
      _msg_info \
        "${_key_fingerprint}"
    fi
  fi
}

_output_type_check() {
  local \
    _output_type="${1}" \
    _output_types=() \
    _evm_gpg_available
  _output_types=(
    ""
    "name"
    "address"
    "fingerprint"
  )
  if [[ " ${_output_types[*]} " != *" ${_output_type} "* ]]; then
    _msg=(
      "Unknown output type '${_output_type}'."
    )
    _msg_error \
      "${_msg[*]}" \
      1
  fi
  if [[ "${output_type}" == "fingerprint" ]]; then
    _key_fingerprint_requirements \
      "y"
  fi
}

_output_type_auto_detect() {
  _set_override \
    "output" \
    "type" \
    ""
  _output_type_check \
    "${output_type}"
}

_set_overrides() {
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
  if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  _set_override \
    "call" \
    "date" \
    "$(_get_date_human)"
  _set_override \
    "tasks" \
    "parallel" \
    "1"
  _cache_dir_auto_detect
  _set_override \
    "networks" \
    "all" \
    "n"
  if [[ "${target_networks[*]}" == "" && \
        "${networks_all}" == "n" ]]; then
    target_networks+=(
      100
    )
  fi
  networks_amount="${#target_networks[@]}"
  _set_override \
    "target" \
    "command" \
    "get"
  _target_key_auto_detect
  _set_override \
    "balance" \
    "lifespan" \
    "3600"
  _set_override \
    "retries" \
    "max" \
    "1"
  _set_override \
    "measure" \
    "unit" \
    "ether"
  _set_override \
    "currency" \
    "address" \
    ""
  _currency_type_auto_detect
  _set_override \
    "rpc" \
    "selection" \
    "kirsh"
  _set_override \
    "explorer" \
    "selection" \
    "kirsh"
  if (( 0 < "${#target_networks[@]}" )); then
    target_network="${target_networks[0]}"
  fi
  if [[ "${currency_type}" != "gas" ]]; then
    if [[ "${target_network}" != "" ]]; then
      _api_key_auto_detect \
        "${target_network}" \
        "${explorer_selection}"
    fi
  fi
  if [[ "${target_command}" != "list" ]]; then
    _wallet_overrides_set \
      "evm-wallet" \
      "${wallet_name}" \
      "y"
  fi
  _key_fingerprint_auto_detect
  _output_type_auto_detect
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _usage_text
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true

EVM network wallet

Usage:
  ${app_name}
    [options]
    <command>
      (<command-args>)

  commands:
    get
      <wallet_name>
      <key>
    list
      <filter>
    set
      <wallet-name>
      <key>
      <value>
    send
      <address>
      <amount>

  keys:
    address
    balance
    seed

  networks:
    all those supported by
    'evm-chains-info' as
    well as direct RPC addresses

  options:
     -R <rpc-selection>       RPC selection method.
                              Default: ${rpc_selection}
     -S <explorer-selection>  Network explorer selection method.
                              Default: ${explorer_selection}
     -r <retries-max>         Maximum number of retries before
                              failing.
                              Default: ${retries_max}
     -u <measure-unit>        Measure unit. It can be
                              'ether' or 'wei'.
                              Default: ${measure_unit}
     -l <balance-lifespan>    Maximum threshold in seconds
                              from now after which to consider
                              balance to be outdated.
                              Default: ${balance_lifespan}
     -a                       Operation valid for all available
                              networks.
     -P <tasks-parallel>      Tasks to perform in parallel.
                              Default: ${tasks_parallel}

  list options:
     -o <output-type>         It can be 'name', 'address',
                              'fingerprint'.
                              Default: ${output_type}

  send options:
     -t <currency-type>       Currency type.
                              It can be 'gas', 'erc20'.
                              Default: ${currency_type}

     -C <currency>            Address of the ERC20
                              token on the network,
                              if type is 'erc20'.
                              Default: ${currency_address}

  credentials options:
     -w <wallet_path>         Wallet path.
                              Default: ${wallet_path}
     -p <wallet_password>     Wallet password.
                              Default: ${wallet_password}
     -s <wallet_seed>         Wallet seed path.
                              Default: ${wallet_seed}
     -k <api_key>             Etherscan-like service key.
                              Default: ${api_key}

  libEVM options:
     -n <network>             EVM network name. Accepted values
                              are all those supported by
                              evm-chains-info and RPC addresses.

  application options:
     -h                       This message.
     -c                       Enable color output
     -v                       Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${1}"
}

_display_flags() {
  local \
    _flags=(
      "${1}"
    ) \
    _flag
  for _flag \
    in "${_flags[@]}"; do
  _msg_info \
    "                             ${_flag}"
  done
}

# Shows configuration options.
_show_config() {
  _msg_info "${app_name} configuration"
  _msg_info "                  Call date:   ${call_date}"
  _msg_info "             Target command:   ${target_command}"
  _msg_info "                Wallet name:   ${wallet_name}"
  _msg_info "                 Target key:   ${target_key}"
  _msg_info "               Target value:   ${target_value}"
  _msg_info "               All networks:   ${networks_all}"
  _msg_info "       RPC selection method:   ${rpc_selection}"
  _msg_info "  Explorer selection method:   ${explorer_selection}"
  _msg_info "               Measure unit:   ${measure_unit}"
  _msg_info "           Balance lifespan:   ${balance_lifespan}"
  _msg_info "             Send options:"
  _msg_info "              Currency type:   ${currency_type}"
  _msg_info "           Currency address:   ${currency_address}"
  _msg_info "             List options:"
  _msg_info "                Output type:   ${output_type}"
  _msg_info "      Credentials options:"
  _msg_info "                Wallet path:   ${wallet_path}"
  _msg_info "            Wallet password:   ${wallet_password}"
  _msg_info "                Wallet seed:   ${wallet_seed}"
  _msg_info "                    API key:   ${api_key}"
  _msg_info "             Wallet address:   ${wallet_address}"
  _msg_info "            Key fingerprint:   ${key_fingerprint}"
  _msg_info "          Network options:"
  _msg_info "            Maximum retries:   ${retries_max}"
  _msg_info "             Parallel tasks:   ${tasks_parallel}"
  _msg_info "           LibEVM options:"
  _msg_info "             Target network:   ${target_network}"
  _msg_info "      Application options:"
  _msg_info "            Cache directory:   ${cache_dir}"
}

_globals
_global_variables
_requirements
_libevm_global_variables
_config_user_init \
  "${app_name}"
# shellcheck disable=SC2034
getopts_opts="$(
  printf \
    "%s" \
    "P:S:E:ar:u:f:l:" \
    "t:C:o:" \
    "$(_libevm_app_getopts_params_get)" \
    "n:" \
    "$(_wallet_getopts_params_get)" \
    "W:cvh")"
while \
  getopts \
    "${getopts_opts}" \
    arg; do
  _wallet_getopts_case
  _libevm_app_getopts_case
  case \
    "${arg}" in
    P)
      override_tasks_parallel="${OPTARG}" ;;
    S)
      override_rpc_selection="${OPTARG}" ;;
    E)
      override_explorer_selection="${OPTARG}" ;;
    a)
      override_networks_all="y" ;;
    r)
      override_retries_max="${OPTARG}" ;;
    l)
      override_balance_lifespan="${OPTARG}" ;;
    u)
      override_measure_unit="${OPTARG}" ;;
    f)
      override_key_fingerprint="${OPTARG}" ;;
    t)
      override_currency_type="${OPTARG}" ;;
    C)
      override_currency_address="${OPTARG}" ;;
    o)
      override_output_type="${OPTARG}" ;;
    n)
      target_networks+=(
        "${OPTARG}"
      ) ;;
      # override_target_network="${OPTARG}" ;;
    W)
      override_cache_dir="${OPTARG}" ;;
    c)
      override_color="y" ;;
    v)
      override_quiet="n" ;;
    h)
      _set_overrides
         _usage \
           0 ;;
    *)
      if [[ " ${getopts_opts} " != *"${arg}"* ]]; then
        _msg=(
          "Invalid argument '${arg}'."
        )
        _msg_error \
          "${_msg[*]}" \
          0
        _set_overrides
        _usage \
          1
      fi ;;
  esac
done
shift \
  $((
    OPTIND - 1 \
  ))
if (( 0 < "${#}" )); then
  target_command="${1}"
fi
if (( 1 < "${#}" )); then
  if [[ "${target_command}" != "list" ]]; then
    wallet_name="${2}"
  else
    target_key="${2}"
  fi
fi
if (( 2 < "$#" )); then
  target_key="${3}"
fi
if (( 3 < $# )); then
  target_value="${4}"
fi
shift \
  4 || \
  true
command_args+=(
  "$@"
)
_set_overrides
_show_config
app_opts=(
  "${target_command}"
  "${wallet_path}"
  "${wallet_password}"
  "${wallet_seed}"
  "${key_fingerprint}"
  "${cache_dir}"
  "${networks_all}"
  "${rpc_selection}"
  "${api_key}"
  "${retries_max}"
  "${tasks_parallel}"
  "${measure_unit}"
  "${balance_lifespan}"
  "${currency_type}"
  "${currency_address}"
  "${output_type}"
  "${target_key}"
  "${target_value}"
  "${networks_amount}"
  "${target_networks[@]}"
)
_evm_wallet \
  "${app_opts[@]}"

# vim:set sw=2 sts=-1 et:
